using MapPiloteGeopackageHelper;
using NetTopologySuite.Geometries;
using NetTopologySuite.IO;
using RoverData.Repository;
using ScentPolygonLibrary;
using Microsoft.Extensions.Options;

// ====== Simple Rover Visualization Application ======

Console.WriteLine("=== FrontendLeaflet Rover Tracker ===");

var builder = WebApplication.CreateBuilder(args);

// Basic services
builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();

// Configure repository based on appsettings.json
var dbType = builder.Configuration["DatabaseConfiguration:DatabaseType"] ?? "geopackage";
var sessionName = builder.Configuration["DatabaseConfiguration:SessionName"] ?? "default";

if (dbType.ToLower() == "postgres")
{
    builder.Services.Configure<PostgresRepositoryOptions>(options =>
    {
        options.ConnectionString = builder.Configuration["DatabaseConfiguration:PostgresConnectionString"] ?? "";
        options.SessionName = sessionName;
    });
    builder.Services.AddScoped<IRoverDataRepository, PostgresRoverDataRepository>();
}
else
{
    builder.Services.Configure<GeoPackageRepositoryOptions>(options =>
    {
        options.FolderPath = builder.Configuration["DatabaseConfiguration:GeoPackageFolderPath"] ?? "/tmp/Rover1";
        options.SessionName = sessionName;
    });
    builder.Services.AddScoped<IRoverDataRepository, GeoPackageRoverDataRepository>();
}

// Initialize repository on startup (for web apps, we need to do this once)
using (var scope = builder.Services.BuildServiceProvider().CreateScope())
{
    var repo = scope.ServiceProvider.GetRequiredService<IRoverDataRepository>();
    await repo.InitializeAsync();
    Console.WriteLine($"Repository initialized for database type '{dbType}'.");
}

// Find forest file path
string FindForestFile()
{
    var possiblePaths = new[]
    {
        Path.Combine(Directory.GetCurrentDirectory(), "..", "Solutionresources", "RiverHeadForest.gpkg"),
        Path.Combine(Directory.GetCurrentDirectory(), "Solutionresources", "RiverHeadForest.gpkg"),
    };
    
    return possiblePaths.FirstOrDefault(File.Exists) ?? possiblePaths[0];
}

var forestPath = FindForestFile();

// Simple scent polygon service with forest path for real-time updates
builder.Services.AddSingleton<ScentPolygonService>(provider =>
{
    // For the scent polygon service, we'll create a dedicated repository instance
    // since it runs as a background service
    IRoverDataRepository repo;
    if (dbType.ToLower() == "postgres")
    {
        var connStr = builder.Configuration["DatabaseConfiguration:PostgresConnectionString"] ?? "";
        var opts = Options.Create(new PostgresRepositoryOptions { ConnectionString = connStr, SessionName = sessionName });
        repo = new PostgresRoverDataRepository(opts);
        repo.InitializeAsync().GetAwaiter().GetResult();
    }
    else
    {
        var folderPath = builder.Configuration["DatabaseConfiguration:GeoPackageFolderPath"] ?? "/tmp/Rover1";
        var opts = Options.Create(new GeoPackageRepositoryOptions { FolderPath = folderPath, SessionName = sessionName });
        repo = new GeoPackageRoverDataRepository(opts);
        repo.InitializeAsync().GetAwaiter().GetResult();
    }
    
    return new ScentPolygonService(repo, forestGeoPackagePath: forestPath);
});
builder.Services.AddHostedService<ScentPolygonService>(provider => provider.GetRequiredService<ScentPolygonService>());

var app = builder.Build();

// Simple middleware setup
//app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");

// ====== API Endpoints (Optimized for Performance) ======

// Basic health check
app.MapGet("/api/test", () => Results.Json(new { status = "OK", time = DateTime.Now }));

// Forest boundary data
app.MapGet("/api/forest", async () =>
{
    try
    {
        var forestPath = FindForestFile();
        if (!File.Exists(forestPath))
            return Results.NotFound("Forest data not found");

        using var geoPackage = await GeoPackage.OpenAsync(forestPath, 4326);
        var layer = await geoPackage.EnsureLayerAsync("riverheadforest", new Dictionary<string, string>(), 4326);
        
        await foreach (var feature in layer.ReadFeaturesAsync(new ReadOptions(IncludeGeometry: true, Limit: 1)))
        {
            if (feature.Geometry is Polygon polygon)
            {
                var geoJsonWriter = new GeoJsonWriter();
                var geoJsonGeometry = geoJsonWriter.Write(polygon);
                
                return Results.Json(new
                {
                    type = "FeatureCollection",
                    features = new[]
                    {
                        new
                        {
                            type = "Feature",
                            properties = new { name = "RiverHead Forest" },
                            geometry = System.Text.Json.JsonSerializer.Deserialize<object>(geoJsonGeometry)
                        }
                    }
                });
            }
        }
        
        return Results.NotFound("No forest data found");
    }
    catch (Exception ex)
    {
        return Results.Problem($"Error: {ex.Message}");
    }
});

// Forest bounds for map centering
app.MapGet("/api/forest-bounds", async () =>
{
    try
    {
        var forestPath = FindForestFile();
        if (!File.Exists(forestPath))
            return Results.NotFound();

        using var geoPackage = await GeoPackage.OpenAsync(forestPath, 4326);
        var layer = await geoPackage.EnsureLayerAsync("riverheadforest", new Dictionary<string, string>(), 4326);
        
        await foreach (var feature in layer.ReadFeaturesAsync(new ReadOptions(IncludeGeometry: true, Limit: 1)))
        {
            if (feature.Geometry is Polygon polygon)
            {
                var envelope = polygon.EnvelopeInternal;
                var centroid = polygon.Centroid;
                
                return Results.Json(new
                {
                    center = new { lat = centroid.Y, lng = centroid.X },
                    bounds = new
                    {
                        minLat = envelope.MinY, maxLat = envelope.MaxY,
                        minLng = envelope.MinX, maxLng = envelope.MaxX
                    }
                });
            }
        }
        
        return Results.NotFound();
    }
    catch
    {
        return Results.NotFound();
    }
});

// OPTIMIZED: Latest rover measurement points (limited for performance)
app.MapGet("/api/rover-data", async (IRoverDataRepository repository, int? limit = 100) =>
{
    try
    {
        // Get total count for statistics
        var totalCount = await repository.GetCountAsync();
        
        // Get limited number of latest measurements for performance
        var measurements = await repository.GetAllAsync();
        var limitedMeasurements = measurements
            .OrderByDescending(m => m.Sequence)
            .Take(limit ?? 100)
            .OrderBy(m => m.Sequence) // Re-order chronologically
            .ToList();
        
        var features = limitedMeasurements.Select(m => new
        {
            type = "Feature",
            properties = new
            {
                sequence = m.Sequence,
                windDirection = m.WindDirectionDeg,
                windSpeed = m.WindSpeedMps,
                time = m.RecordedAt.ToString("HH:mm:ss")
            },
            geometry = new
            {
                type = "Point",
                coordinates = new[] { m.Longitude, m.Latitude }
            }
        });
        
        return Results.Json(new { 
            type = "FeatureCollection", 
            features,
            metadata = new { 
                totalCount, 
                shownCount = limitedMeasurements.Count,
                isLimited = totalCount > (limit ?? 100)
            }
        });
    }
    catch (Exception ex)
    {
        return Results.Json(new { 
            type = "FeatureCollection", 
            features = new object[0],
            error = ex.Message
        });
    }
});

// NEW: Rover trail as a single LineString for better performance with many points
// If 'after' timestamp is provided, only returns points after that time
app.MapGet("/api/rover-trail", async (IRoverDataRepository repository, string? after = null) =>
{
    try
    {
        var measurements = await repository.GetAllAsync();
        
        if (!measurements.Any())
            return Results.Json(new { type = "FeatureCollection", features = new object[0] });
        
        // Filter by timestamp if 'after' parameter is provided
        var filteredMeasurements = measurements.OrderBy(m => m.Sequence);
        
        if (!string.IsNullOrEmpty(after) && DateTime.TryParse(after, out var afterTime))
        {
            filteredMeasurements = filteredMeasurements.Where(m => m.RecordedAt > afterTime).OrderBy(m => m.Sequence);
        }
        
        var limitedMeasurements = filteredMeasurements.ToList();
        
        if (!limitedMeasurements.Any())
            return Results.Json(new { type = "FeatureCollection", features = new object[0] });
        
        // Create a LineString from the coordinates
        var coordinates = limitedMeasurements
            .Select(m => new[] { m.Longitude, m.Latitude })
            .ToArray();
        
        var lineFeature = new
        {
            type = "Feature",
            properties = new
            {
                name = "Rover Trail",
                pointCount = limitedMeasurements.Count,
                totalPoints = measurements.Count(),
                startTime = limitedMeasurements.First().RecordedAt.ToString("o"),
                endTime = limitedMeasurements.Last().RecordedAt.ToString("o")
            },
            geometry = new
            {
                type = "LineString",
                coordinates
            }
        };
        
        return Results.Json(new { 
            type = "FeatureCollection", 
            features = new[] { lineFeature }
        });
    }
    catch (Exception ex)
    {
        return Results.Json(new { 
            type = "FeatureCollection", 
            features = new object[0],
            error = ex.Message
        });
    }
});

// OPTIMIZED: Rover statistics for info display
app.MapGet("/api/rover-stats", async (IRoverDataRepository repository) =>
{
    try
    {
        var totalCount = await repository.GetCountAsync();
        var latest = await repository.GetLatestAsync();
        
        return Results.Json(new
        {
            totalMeasurements = totalCount,
            latestSequence = latest?.Sequence ?? -1,
            latestTime = latest?.RecordedAt.ToString("HH:mm:ss"),
            latestPosition = latest != null ? new { 
                lat = latest.Latitude, 
                lng = latest.Longitude,
                windSpeed = latest.WindSpeedMps,
                windDirection = latest.WindDirectionDeg
            } : null
        });
    }
    catch (Exception ex)
    {
        return Results.Json(new { 
            error = ex.Message,
            totalMeasurements = 0
        });
    }
});

// NEW: Sampling API - get evenly distributed points for large datasets
app.MapGet("/api/rover-sample", async (IRoverDataRepository repository, int? sampleSize = 200) =>
{
    try
    {
        var measurements = await repository.GetAllAsync();
        
        if (!measurements.Any())
            return Results.Json(new { type = "FeatureCollection", features = new object[0] });
        
        var orderedMeasurements = measurements.OrderBy(m => m.Sequence).ToList();
        var totalCount = orderedMeasurements.Count;
        var requestedSample = sampleSize ?? 200;
        
        List<RoverMeasurement> sampledMeasurements;
        
        if (totalCount <= requestedSample)
        {
            // If we have fewer points than requested, return all
            sampledMeasurements = orderedMeasurements;
        }
        else
        {
            // Sample evenly across the dataset
            sampledMeasurements = new List<RoverMeasurement>();
            var step = (double)totalCount / requestedSample;
            
            for (int i = 0; i < requestedSample; i++)
            {
                var index = (int)Math.Round(i * step);
                if (index >= totalCount) index = totalCount - 1;
                sampledMeasurements.Add(orderedMeasurements[index]);
            }
        }
        
        var features = sampledMeasurements.Select(m => new
        {
            type = "Feature",
            properties = new
            {
                sequence = m.Sequence,
                windDirection = m.WindDirectionDeg,
                windSpeed = m.WindSpeedMps,
                time = m.RecordedAt.ToString("HH:mm:ss")
            },
            geometry = new
            {
                type = "Point",
                coordinates = new[] { m.Longitude, m.Latitude }
            }
        });
        
        return Results.Json(new { 
            type = "FeatureCollection", 
            features,
            metadata = new {
                totalCount,
                sampleSize = sampledMeasurements.Count,
                samplingRatio = (double)sampledMeasurements.Count / totalCount
            }
        });
    }
    catch (Exception ex)
    {
        return Results.Json(new { 
            type = "FeatureCollection", 
            features = new object[0],
            error = ex.Message
        });
    }
});

// Combined coverage area (the only scent visualization we need)
app.MapGet("/api/combined-coverage", (ScentPolygonService scentService) =>
{
    try
    {
        var unified = scentService.GetUnifiedScentPolygonCached();
        if (unified == null || !unified.IsValid)
            return Results.NotFound("No coverage data available");

        var geoJsonWriter = new GeoJsonWriter();
        var geoJsonGeometry = geoJsonWriter.Write(unified.Polygon);

        return Results.Json(new
        {
            type = "FeatureCollection",
            features = new[]
            {
                new
                {
                    type = "Feature",
                    properties = new
                    {
                        totalPolygons = unified.PolygonCount,
                        areaHectares = Math.Round(unified.TotalAreaM2 / 10000.0, 1),
                        avgWindSpeed = Math.Round(unified.AverageWindSpeedMps, 1)
                    },
                    geometry = System.Text.Json.JsonSerializer.Deserialize<object>(geoJsonGeometry)
                }
            }
        });
    }
    catch
    {
        return Results.NotFound();
    }
});

// ====== Helper Functions ======

Console.WriteLine("Starting FrontendLeaflet rover tracker...");
Console.WriteLine("Performance optimizations enabled for large datasets");
Console.WriteLine("Using Leaflet.js for interactive mapping");
Console.WriteLine("Open your browser to see the clean map visualization");

app.Run();
