@page "/"
@using FrontendOpenLayers.Components
@using NetTopologySuite.Geometries
@using ScentPolygonLibrary
@using RoverData.Repository
@inject IServiceProvider ServiceProvider
@inject ForestBoundaryReader ForestBoundaryReader

<ScentMap @ref="_map" />

<div style="position: fixed; top: 10px; left: 10px; z-index: 1000; background: rgba(255,255,255,0.95); padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); pointer-events: auto; max-width: 300px; width: auto; height: auto;">
    <h3 style="margin: 0 0 15px 0; font-size: 1.5rem; color: #2d5a27;">FrontendOpenLayers Rover Tracker</h3>
    <ForestCoveragePie />
</div>

@if (!string.IsNullOrEmpty(_error))
{
    <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1001; background: rgba(220, 53, 69, 0.95); color: white; padding: 10px 20px; border-radius: 6px; pointer-events: auto;">
        Error: @_error
    </div>
}

@code {
    private ScentMap? _map;
    private string? _error;
    private Timer? _timer;
    private Dictionary<Guid, int> _lastSequencePerRover = new();
    private bool _boundaryLoaded = false;
    private bool _disposed = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Task.Delay(500);
            
            try
            {
                await LoadDataAsync();
                _timer = new Timer(async _ =>
                {
                    if (_disposed) return;
                    
                    try
                    {
                        await InvokeAsync(async () => await LoadDataAsync());
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Timer error: {ex.Message}");
                    }
                }, null, TimeSpan.FromSeconds(8), TimeSpan.FromSeconds(8));
            }
            catch (Exception ex)
            {
                _error = $"Init error: {ex.Message}";
                Console.WriteLine($"OnAfterRenderAsync error: {ex}");
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task LoadDataAsync()
    {
        if (_disposed) return;
        
        try
        {
            Console.WriteLine("Index: LoadDataAsync starting...");
            
            if (!_boundaryLoaded)
            {
                var forestBoundary = await ForestBoundaryReader.GetBoundaryPolygonAsync();
                if (forestBoundary != null && _map != null)
                {
                    await _map.UpdateForestBoundaryAsync(forestBoundary);
                    Console.WriteLine("Index: Forest boundary loaded");
                }
                _boundaryLoaded = true;
            }

            using var scope = ServiceProvider.CreateScope();
            var reader = scope.ServiceProvider.GetRequiredService<IRoverDataRepository>();
            var generator = scope.ServiceProvider.GetRequiredService<ScentPolygonGenerator>();      
            
            var allPoints = await reader.GetAllAsync();
            var allRoverIds = allPoints.Select(p => p.RoverId).Distinct().ToHashSet();
            var newRoverIds = allRoverIds.Where(id => !_lastSequencePerRover.ContainsKey(id)).ToList();
            
            List<RoverMeasurement> newPoints = new();
            
            if (newRoverIds.Count > 0)
            {
                var allNewRoverPoints = allPoints.Where(p => newRoverIds.Contains(p.RoverId)).ToList();
                newPoints.AddRange(allNewRoverPoints);
                Console.WriteLine($"Index: Found {newRoverIds.Count} new rover(s) with {allNewRoverPoints.Count} total points");
            }
            
            var minLastSequence = _lastSequencePerRover.Count > 0 ? _lastSequencePerRover.Values.Min() : 0;
            var incrementalPoints = await reader.GetNewSinceSequenceAsync(minLastSequence);
            newPoints.AddRange(incrementalPoints.Where(p => !newRoverIds.Contains(p.RoverId)));
            
            if (newPoints.Count == 0)
            {
                await InvokeAsync(StateHasChanged);
                return;
            }

            // Group measurements by rover
            var roverGroups = newPoints.GroupBy(p => new { p.RoverId, p.RoverName });
            Console.WriteLine($"Index: Found {roverGroups.Count()} rovers with {newPoints.Count} total points");

            // Update trail and position for each rover
            foreach (var roverGroup in roverGroups)
            {
                var roverPoints = roverGroup.OrderBy(p => p.Sequence).ToList();
                var coordinates = roverPoints.Select(p => p.Geometry.Coordinate).ToArray();
                
                if (coordinates.Length == 0) continue;

                var isNewRover = !_lastSequencePerRover.ContainsKey(roverGroup.Key.RoverId);
                
                if (_map != null)
                {
                    if (coordinates.Length >= 2)
                    {
                        if (isNewRover)
                        {
                            var trail = new LineString(coordinates);
                            await _map.UpdateRoverTrailAsync(roverGroup.Key.RoverId, roverGroup.Key.RoverName, trail);
                        }
                        else
                        {
                            var lastSeq = _lastSequencePerRover[roverGroup.Key.RoverId];
                            var newCoords = roverPoints.Where(p => p.Sequence > lastSeq).Select(p => p.Geometry.Coordinate).ToArray();
                            if (newCoords.Length > 0)
                            {
                                await _map.AppendRoverTrailCoordsAsync(roverGroup.Key.RoverId, roverGroup.Key.RoverName, newCoords);
                            }
                        }
                    }
                    
                    var latest = roverPoints.Last();
                    await _map.UpdateRoverPositionAsync(
                        roverGroup.Key.RoverId,
                        roverGroup.Key.RoverName,
                        latest.Geometry,
                        latest.WindSpeedMps,
                        latest.WindDirectionDeg
                    );
                }
                
                // Track last sequence per rover
                _lastSequencePerRover[roverGroup.Key.RoverId] = roverPoints.Max(p => p.Sequence);
                
                var action = isNewRover ? "Initialized" : "Updated";
                Console.WriteLine($"Index: {action} rover {roverGroup.Key.RoverName} with {roverPoints.Count} points, last seq: {_lastSequencePerRover[roverGroup.Key.RoverId]}");
            }

            var coverage = await generator.GetUnifiedPolygonAsync();
            if (coverage?.Polygon != null && _map != null)
            {
                await _map.UpdateCoverageAsync(coverage.Polygon);
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            Console.WriteLine($"LoadDataAsync error: {ex}");
            await InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        _disposed = true;
        _timer?.Dispose();
    }
}