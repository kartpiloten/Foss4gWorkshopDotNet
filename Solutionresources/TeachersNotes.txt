- Vi startar hela övningen med ett motiverande demo av systemet där vi visar programmeet och ser till att alla kan köra det.


Övning 1
Nytillverkad rover av en underleverantör (som levererar Roverpunkter i fel koordinatsystem.)
- Anders kör sin felaktiga rover från sin dator som gör att punkterna hamnar fel.
-- I grundversionen av systemet så är det geografiska objektet typat som Geometry.
Påverkar inte funktionen om rovern skickar rätt srid
Filen: PostgresRoverDataRepository.cs --> InitializeAsync
CREATE TABLE IF NOT EXISTS roverdata.rover_measurements (
    id BIGSERIAL PRIMARY KEY,
    geom geometry(Geometry),
    session_id UUID NOT NULL,
    sequence INT NOT NULL,
    recorded_at TIMESTAMPTZ NOT NULL,
    latitude DOUBLE PRECISION NOT NULL,
    longitude DOUBLE PRECISION NOT NULL,
    wind_direction_deg SMALLINT NOT NULL,
    wind_speed_mps REAL NOT NULL
);
-- Gjort search and replace i koden för att ändra koordinatsystemet från 4326 till 3006

Joakim och deltagarna kör frontend 
- Vi ger deltagarna några minuter att fundera på hur de skulle lösa problemet.
- Efter det så diskuterar vi deras lösningar och hur vi kan implementera dem i systemet.

Jokaim börjar att ändra typningen till (point, 4326)
Filen: PostgresRoverDataRepository.cs --> InitializeAsync
CREATE TABLE IF NOT EXISTS roverdata.rover_measurements (
    id BIGSERIAL PRIMARY KEY,
    geom geometry(Point, 4326),
    session_id UUID NOT NULL,
    sequence INT NOT NULL,
    recorded_at TIMESTAMPTZ NOT NULL,
    latitude DOUBLE PRECISION NOT NULL,
    longitude DOUBLE PRECISION NOT NULL,
    wind_direction_deg SMALLINT NOT NULL,
    wind_speed_mps REAL NOT NULL
);
- Då genereras ett felmeddelande om att koordinatsystemet är ogiltigt.
- Anders ändrar i sin Rover-konfiguration till rätt koordinatsystem (4326).

Övning 2
I ursprungsversionen producerar ScentPolygonLibrary endast en "fan"-polygon för varje Roverpunkt.
I denna övning lägger vi till ett område runt rovern baserat på att hundförare och hund har ett område kring sig
där de kan upptäcka människor oavsett vindriktning.
Beräkningen sker i ScentPolygonLibrary i filen ScentPolygonCalculator.cs funktionen CreateScentPolygon.
Ursprungskoden är:
        var fan = geometryFactory.CreatePolygon(geometryFactory.CreateLinearRing(fanCoords.ToArray()));
        fan.SRID = 4326;
        // *** Excercise 2 ***
        // *** Add code here to add a circular buffer around the dog position *** 
        // Small circular buffer around the dog to always include a local detection zone

        return fan;

Uppdaterade koden är:
        var fan = geometryFactory.CreatePolygon(geometryFactory.CreateLinearRing(fanCoords.ToArray()));
        fan.SRID = 4326;
        // *** Excercise 2 ***
        // *** Add code here to add a circular buffer around the dog position *** 
        // Small circular buffer around the dog to always include a local detection zone
        var bufferRadiusDegrees = config.OmnidirectionalRadiusMeters / metersPerDegLat;
        var smallBuffer = dogPoint.Buffer(bufferRadiusDegrees); // NTS Buffer: circle approximation in lat/lon degrees

        // Combine fan and buffer (union). Handle common result types simply.

        Geometry finalPolygon = fan.Union(smallBuffer);
  
        finalPolygon.SRID = 4326;
        return (Polygon)finalPolygon;

Övning 3
Frontend: Utöka statistik-komponenten med rover-data och GIS-beräkningar

Mål: Utöka den befintliga Blazor-komponenten ForestCoveragePie.razor med:
- Total distans som rovern färdats (beräknad med Haversine-formeln)
- Medel/min/max vindhastighet från alla mätpunkter

Fil att ändra: FrontendLeaflet/Components/ForestCoveragePie.razor

Steg 1: Injicera IRoverDataReader i komponenten
Lägg till längst upp:
@inject ReadRoverDBStubLibrary.IRoverDataReader RoverReader

Steg 2: Lägg till nya privata fält i @code-sektionen:
    private double _totalDistanceKm = 0;
    private double _avgWindSpeed = 0;
    private double _minWindSpeed = 0;
    private double _maxWindSpeed = 0;

Steg 3: Skapa en metod för Haversine-beräkning:
    private double CalculateHaversineDistance(double lat1, double lon1, double lat2, double lon2)
    {
        const double R = 6371; // Jordens radie i km
        var dLat = (lat2 - lat1) * Math.PI / 180.0;
        var dLon = (lon2 - lon1) * Math.PI / 180.0;
        
        var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                Math.Cos(lat1 * Math.PI / 180.0) * Math.Cos(lat2 * Math.PI / 180.0) *
                Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
        
        var c = 2 * Math.Asin(Math.Sqrt(a));
        return R * c;
    }

Steg 4: Skapa en async metod för att uppdatera rover-statistik:
    private async Task UpdateRoverStatistics()
    {
        try
        {
            var measurements = await RoverReader.GetAllMeasurementsAsync();
            var ordered = measurements.OrderBy(m => m.Sequence).ToList();
            
            if (!ordered.Any()) return;
            
            // Beräkna total distans
            _totalDistanceKm = 0;
            for (int i = 1; i < ordered.Count; i++)
            {
                _totalDistanceKm += CalculateHaversineDistance(
                    ordered[i-1].Latitude, ordered[i-1].Longitude,
                    ordered[i].Latitude, ordered[i].Longitude);
            }
            
            // Beräkna vindstatistik
            _avgWindSpeed = ordered.Average(m => m.WindSpeedMps);
            _minWindSpeed = ordered.Min(m => m.WindSpeedMps);
            _maxWindSpeed = ordered.Max(m => m.WindSpeedMps);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating rover statistics: {ex.Message}");
        }
    }

Steg 5: Anropa UpdateRoverStatistics från OnForestCoverageUpdated:
    private void OnForestCoverageUpdated(object? sender, ScentPolygonLibrary.ForestCoverageEventArgs e)
    {
        _searchedAreaM2 = e.SearchedAreaM2;
        _forestAreaM2 = e.ForestAreaM2;
        _percentage = e.PercentageSearched;
        
        if (_percentage > 100) _percentage = 100;
        
        // Uppdatera även rover-statistik
        _ = UpdateRoverStatistics(); // Fire-and-forget
        
        InvokeAsync(StateHasChanged);
    }

Steg 6: Lägg till nya rader i HTML-sektionen efter "Searched":
        <div class="info-row">
            <span class="info-label">Total Distance:</span>
            <span class="info-value">@_totalDistanceKm.ToString("F2") km</span>
        </div>
        <div class="info-row">
            <span class="info-label">Avg Wind:</span>
            <span class="info-value">@_avgWindSpeed.ToString("F1") m/s</span>
        </div>
        <div class="info-row">
            <span class="info-label">Min/Max Wind:</span>
            <span class="info-value">@_minWindSpeed.ToString("F1") / @_maxWindSpeed.ToString("F1") m/s</span>
        </div>

Diskussionspunkter:
- Varför använder vi Haversine istället för Pythagoras? (Jordens krökning)
- Är beräkningen exakt? (Nej, approximation - jordens avplattning, elevationsförändringar)
- Prestanda: Hur många punkter kan vi hantera innan beräkningen tar för lång tid?
- Alternativ: Skulle vi kunna beräkna distansen i databasen med PostGIS ST_Distance?
