We start the entire exercise with a motivating demo of the system where we show the program and make sure everyone can run it.

Exercise 1
Start QGIS and connect to the PostGIS database used by the Rover system. Start PGAdmin and navigate to the roverdata schema.
The connection string in appsettings.json is:
"Host=postgis-demo-nz.postgres.database.azure.com;Port=5432;Username=postgres;Password=WorkshopGavle2025;Database=aucklandroverdata;Timeout=60;Command Timeout=60",

Run the following SQL:
SELECT
rp.id,
rp.geom,
rp.rover_id,
rp.rover_name,
rp.session_id,
rs.session_name,
rp.sequence,
rp.recorded_at,
rp.wind_direction_deg,
rp.wind_speed_mps
FROM roverdata.rover_points rp
LEFT JOIN roverdata.rover_sessions rs ON rp.session_id = rs.session_id
WHERE rs.session_name = 'test1'::text;

Go back to QGIS and refresh the layer list to see the new layer.

Exercise 2
In the original version, the ScentPolygonLibrary produces only a “fan” polygon for each rover point. In this exercise we add an additional area around the rover based on the fact that the handler and dog have a local zone around them where they can detect people regardless of wind direction.

The calculation takes place in ScentPolygonLibrary in the file ScentPolygonCalculator.cs, function CreateScentPolygon.
The original code is:

var fan = geometryFactory.CreatePolygon(geometryFactory.CreateLinearRing(fanCoords.ToArray()));
fan.SRID = 4326;
// *** Exercise 2 ***
// *** Add code here to add a circular buffer around the dog position ***
// Small circular buffer around the dog to always include a local detection zone
return fan;

The updated code is:

var fan = geometryFactory.CreatePolygon(geometryFactory.CreateLinearRing(fanCoords.ToArray()));
fan.SRID = 4326;
// *** Exercise 2 ***
// Small circular buffer around the dog to always include a local detection zone
var bufferRadiusDegrees = config.OmnidirectionalRadiusMeters / metersPerDegLat;
var smallBuffer = dogPoint.Buffer(bufferRadiusDegrees); // NTS Buffer: circle approximation in lat/lon degrees

// Combine fan and buffer (union). Handle common result types simply.
Geometry finalPolygon = fan.Union(smallBuffer);

finalPolygon.SRID = 4326;
return (Polygon)finalPolygon;

Exercise 3
Frontend: Extend the statistics component with rover data and GIS calculations.
Goal: Extend the existing Blazor component ForestCoveragePie.razor with:

Total distance travelled by the rover (using the Haversine formula)

Average / min / max wind speed from all measurement points

File to modify: FrontendLeaflet/Components/ForestCoveragePie.razor

Step 1: Inject IRoverDataRepository into the component:
@inject RoverData.Repository.IRoverDataRepository RoverRepository

Step 2: Add new private fields in the @code section:
private double _totalDistanceKm = 0;
private double _avgWindSpeed = 0;
private double _minWindSpeed = 0;
private double _maxWindSpeed = 0;

Step 3: Create a method for Haversine calculation:
private double CalculateHaversineDistance(double lat1, double lon1, double lat2, double lon2)
{
const double R = 6371;
var dLat = (lat2 - lat1) * Math.PI / 180.0;
var dLon = (lon2 - lon1) * Math.PI / 180.0;

var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +  
        Math.Cos(lat1 * Math.PI / 180.0) * Math.Cos(lat2 * Math.PI / 180.0) *  
        Math.Sin(dLon / 2) * Math.Sin(dLon / 2);  

var c = 2 * Math.Asin(Math.Sqrt(a));  
return R * c;  


}

Step 4: Create an async method to update rover statistics:
private async Task UpdateRoverStatistics()
{
try
{
var measurements = await RoverRepository.GetAllAsync();
if (!measurements.Any()) return;

    var roverGroups = measurements.GroupBy(m => new { m.RoverId, m.RoverName });  

    _totalDistanceKm = 0;  
    var allWindSpeeds = new List<float>();  

    foreach (var roverGroup in roverGroups)  
    {  
        var roverPoints = roverGroup.OrderBy(m => m.Sequence).ToList();  

        for (int i = 1; i < roverPoints.Count; i++)  
        {  
            _totalDistanceKm += CalculateHaversineDistance(  
                roverPoints[i - 1].Latitude, roverPoints[i - 1].Longitude,  
                roverPoints[i].Latitude, roverPoints[i].Longitude);  
        }  

        allWindSpeeds.AddRange(roverGroup.Select(m => m.WindSpeedMps));  
    }  

    _avgWindSpeed = allWindSpeeds.Any() ? allWindSpeeds.Average() : 0;  
    _minWindSpeed = allWindSpeeds.Any() ? allWindSpeeds.Min() : 0;  
    _maxWindSpeed = allWindSpeeds.Any() ? allWindSpeeds.Max() : 0;  
}  
catch (Exception ex)  
{  
    Console.WriteLine($"Error updating rover statistics: {ex.Message}");  
}  


}

Step 5: Update PollForUpdates to also update rover statistics:
private async Task PollForUpdates()
{
try
{
var (searchedArea, forestArea) = await Generator.GetForestIntersectionAreasAsync();
_searchedAreaM2 = searchedArea;
_forestAreaM2 = forestArea;
_percentage = forestArea > 0 ? ((double)searchedArea / forestArea) * 100 : 0;

    if (_percentage > 100) _percentage = 100;  

    await UpdateRoverStatistics();  
    await InvokeAsync(StateHasChanged);  
}  
catch  
{  
    // Ignore polling errors  
}  


}

Step 6: Add new rows in the HTML section after “Searched”:

<div class="info-row"> <span class="info-label">Total Distance:</span> <span class="info-value">@_totalDistanceKm.ToString("F2") km</span> </div> <div class="info-row"> <span class="info-label">Avg Wind:</span> <span class="info-value">@_avgWindSpeed.ToString("F1") m/s</span> </div> <div class="info-row"> <span class="info-label">Min/Max Wind:</span> <span class="info-value">@_minWindSpeed.ToString("F1") / @_maxWindSpeed.ToString("F1") m/s</span> </div>

Discussion points:

Why do we use Haversine instead of Pythagoras? (Earth’s curvature)

Is the calculation exact? (No, it is an approximation affected by Earth’s flattening and elevation changes)

Performance: How many points can we process before the calculation becomes too slow?

Alternatives: Could we calculate the distance in the database using PostGIS ST_Distance?
