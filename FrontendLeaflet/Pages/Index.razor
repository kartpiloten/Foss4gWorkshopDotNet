@page "/"
@using FrontendLeaflet.Components
@using NetTopologySuite.Geometries
@using ScentPolygonLibrary
@using RoverData.Repository
@inject IServiceProvider ServiceProvider
@inject ForestBoundaryReader ForestBoundaryReader

<ScentMap @ref="_map" />

<div style="position: fixed; top: 10px; left: 10px; z-index: 1000; background: rgba(255,255,255,0.75); padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); pointer-events: auto; max-width: 300px; width: auto; height: auto;">
    <h3 style="margin: 0 0 15px 0; font-size: 1.5rem; color: #2d5a27;">FrontendLeaflet Rover Tracker</h3>
    <ForestCoveragePie />
</div>

@if (!string.IsNullOrEmpty(_error))
{
    <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1001; background: rgba(220, 53, 69, 0.95); color: white; padding: 10px 20px; border-radius: 6px; pointer-events: auto;">
        Error: @_error
    </div>
}

@code {
    private ScentMap? _map;
    private string? _error;
    private Timer? _timer;
    private Dictionary<Guid, int> _lastSequencePerRover = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Task.Delay(500);
            
            try
            {
                await LoadInitialDataAsync();
                _timer = new Timer(async _ =>
                {
                    try
                    {
                        await InvokeAsync(async () => await LoadIncrementalDataAsync());
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Timer error: {ex.Message}");
                    }
                }, null, TimeSpan.FromSeconds(8), TimeSpan.FromSeconds(8));
            }
            catch (Exception ex)
            {
                _error = $"Init error: {ex.Message}";
                Console.WriteLine($"OnAfterRenderAsync error: {ex}");
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task LoadInitialDataAsync()
    {
        Console.WriteLine("Index: LoadInitialDataAsync starting...");
        try
        {
            // Load forest boundary first
            var forestBoundary = await ForestBoundaryReader.GetBoundaryPolygonAsync();
            if (forestBoundary != null && _map != null)
            {
                await _map.UpdateForestBoundaryAsync(forestBoundary);
                Console.WriteLine("Index: Forest boundary loaded");
            }

            using var scope = ServiceProvider.CreateScope();
            var reader = scope.ServiceProvider.GetRequiredService<IRoverDataRepository>();
            var generator = scope.ServiceProvider.GetRequiredService<ScentPolygonGenerator>();      
            var points = await reader.GetAllAsync();
            
            if (points.Count == 0)
            {
                await InvokeAsync(StateHasChanged);
                return;
            }

            // Group measurements by rover
            var roverGroups = points.GroupBy(p => new { p.RoverId, p.RoverName });
            Console.WriteLine($"Index: Found {roverGroups.Count()} rovers with {points.Count} total points");

            // Update trail and position for each rover
            foreach (var roverGroup in roverGroups)
            {
                var roverPoints = roverGroup.OrderBy(p => p.Sequence).ToList();
                var coordinates = roverPoints.Select(p => new Coordinate(p.Longitude, p.Latitude)).ToArray();
                var trail = new LineString(coordinates);
                
                if (_map != null)
                {
                    await _map.UpdateRoverTrailAsync(roverGroup.Key.RoverId, roverGroup.Key.RoverName, trail);
                    
                    var latest = roverPoints.Last();
                    await _map.UpdateRoverPositionAsync(
                        roverGroup.Key.RoverId,
                        roverGroup.Key.RoverName,
                        new Point(latest.Longitude, latest.Latitude),
                        latest.WindSpeedMps,
                        latest.WindDirectionDeg
                    );
                }
                
                // Track last sequence per rover
                _lastSequencePerRover[roverGroup.Key.RoverId] = roverPoints.Max(p => p.Sequence);
                
                Console.WriteLine($"Index: Updated rover {roverGroup.Key.RoverName} with {roverPoints.Count} points, last seq: {_lastSequencePerRover[roverGroup.Key.RoverId]}");
            }

            Console.WriteLine($"Index: Getting combined coverage polygon for {points.Count} points...");
            var coverage = await generator.GetUnifiedPolygonAsync();
            Console.WriteLine($"Index: Coverage geometry null? {coverage?.Polygon == null}");
            if (coverage?.Polygon != null && _map != null)
            {
                Console.WriteLine($"Index: Calling UpdateCoverageAsync with geometry type {coverage.Polygon.GeometryType}");
                await _map.UpdateCoverageAsync(coverage.Polygon);
                Console.WriteLine("Index: UpdateCoverageAsync completed");
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            Console.WriteLine($"LoadInitialDataAsync error: {ex}");
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task LoadIncrementalDataAsync()
    {
        try
        {
            using var scope = ServiceProvider.CreateScope();
            var reader = scope.ServiceProvider.GetRequiredService<IRoverDataRepository>();
            var generator = scope.ServiceProvider.GetRequiredService<ScentPolygonGenerator>();
            
            // Get the minimum last sequence across all rovers (or 0 if none)
            var minLastSequence = _lastSequencePerRover.Count > 0 ? _lastSequencePerRover.Values.Min() : 0;
            var newPoints = await reader.GetNewSinceSequenceAsync(minLastSequence);
            if (newPoints.Count == 0) return;
            
            // Group new points by rover
            var roverGroups = newPoints.GroupBy(p => new { p.RoverId, p.RoverName });
            
            foreach (var roverGroup in roverGroups)
            {
                // Get last sequence for this specific rover
                var lastSeq = _lastSequencePerRover.GetValueOrDefault(roverGroup.Key.RoverId, 0);
                
                // Filter to only points newer than this rover's last sequence
                var roverNewPoints = roverGroup.Where(p => p.Sequence > lastSeq).OrderBy(p => p.Sequence).ToList();
                
                if (roverNewPoints.Count == 0) continue;
                
                var newCoords = roverNewPoints.Select(p => new Coordinate(p.Longitude, p.Latitude)).ToArray();
                
                if (_map != null)
                {
                    await _map.AppendRoverTrailCoordsAsync(roverGroup.Key.RoverId, roverGroup.Key.RoverName, newCoords);
                    
                    var latest = roverNewPoints.Last();
                    await _map.UpdateRoverPositionAsync(
                        roverGroup.Key.RoverId,
                        roverGroup.Key.RoverName,
                        new Point(latest.Longitude, latest.Latitude),
                        latest.WindSpeedMps,
                        latest.WindDirectionDeg
                    );
                }
                
                // Update last sequence for this rover
                _lastSequencePerRover[roverGroup.Key.RoverId] = roverNewPoints.Max(p => p.Sequence);
                Console.WriteLine($"Index: Updated rover {roverGroup.Key.RoverName} with {roverNewPoints.Count} new points, last seq: {_lastSequencePerRover[roverGroup.Key.RoverId]}");
            }

            var coverage = await generator.GetUnifiedPolygonAsync();
            if (coverage?.Polygon != null && _map != null)
            {
                await _map.UpdateCoverageAsync(coverage.Polygon);
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    public void Dispose()
    {
        _timer?.Dispose();
    }
}
