@page "/"
@using FrontendLeaflet.Components
@using NetTopologySuite.Geometries
@using ScentPolygonLibrary
@using RoverData.Repository
@inject IServiceProvider ServiceProvider
@inject ForestBoundaryReader ForestBoundaryReader

<ScentMap @ref="_map" />

<div style="position: fixed; top: 10px; left: 10px; z-index: 1000; background: rgba(255,255,255,0.75); padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); pointer-events: auto; max-width: 300px; width: auto; height: auto;">
    <h3 style="margin: 0 0 15px 0; font-size: 1.5rem; color: #2d5a27;">FrontendLeaflet Rover Tracker</h3>
    <ForestCoveragePie />
</div>

@if (!string.IsNullOrEmpty(_error))
{
    <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1001; background: rgba(220, 53, 69, 0.95); color: white; padding: 10px 20px; border-radius: 6px; pointer-events: auto;">
        Error: @_error
    </div>
}

@code {
    private ScentMap? _map;
    private string? _error;
    private Timer? _timer;
    private Dictionary<Guid, int> _lastSequencePerRover = new();
    private Dictionary<Guid, int> _pointCountPerRover = new();
    private bool _boundaryLoaded = false;
    private bool _disposed = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Task.Delay(500);
            
            try
            {
                await LoadDataAsync();
                _timer = new Timer(async _ =>
                {
                    if (_disposed) return;
                    
                    try
                    {
                        await InvokeAsync(async () => await LoadDataAsync());
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Timer error: {ex.Message}");
                    }
                }, null, TimeSpan.FromSeconds(8), TimeSpan.FromSeconds(8));
            }
            catch (Exception ex)
            {
                _error = $"Init error: {ex.Message}";
                Console.WriteLine($"OnAfterRenderAsync error: {ex}");
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task LoadDataAsync()
    {
        if (_disposed) return;
        
        try
        {
            Console.WriteLine("Index: LoadDataAsync starting...");
            
            if (!_boundaryLoaded)
            {
                var forestBoundary = await ForestBoundaryReader.GetBoundaryPolygonAsync();
                if (forestBoundary != null && _map != null)
                {
                    await _map.UpdateForestBoundaryAsync(forestBoundary);
                    Console.WriteLine("Index: Forest boundary loaded");
                }
                _boundaryLoaded = true;
            }

            using var scope = ServiceProvider.CreateScope();
            var reader = scope.ServiceProvider.GetRequiredService<IRoverDataRepository>();
            var generator = scope.ServiceProvider.GetRequiredService<ScentPolygonGenerator>();      
            
            var allPoints = await reader.GetAllAsync();
            var allRoverIds = allPoints.Select(p => p.RoverId).Distinct().ToHashSet();
            var newRoverIds = allRoverIds.Where(id => !_lastSequencePerRover.ContainsKey(id)).ToList();
            
            List<RoverMeasurement> newPoints = new();
            
            if (newRoverIds.Count > 0)
            {
                var allNewRoverPoints = allPoints.Where(p => newRoverIds.Contains(p.RoverId)).ToList();
                newPoints.AddRange(allNewRoverPoints);
                Console.WriteLine($"Index: Found {newRoverIds.Count} new rover(s) with {allNewRoverPoints.Count} total points");
            }
            
            var minLastSequence = _lastSequencePerRover.Count > 0 ? _lastSequencePerRover.Values.Min() : 0;
            var incrementalPoints = await reader.GetNewSinceSequenceAsync(minLastSequence);
            newPoints.AddRange(incrementalPoints.Where(p => !newRoverIds.Contains(p.RoverId) && p.Sequence > _lastSequencePerRover.GetValueOrDefault(p.RoverId, 0)));
            
            if (newPoints.Count == 0)
            {
                await InvokeAsync(StateHasChanged);
                return;
            }

            // Group measurements by rover
            var roverGroups = newPoints.GroupBy(p => new { p.RoverId, p.RoverName });
            Console.WriteLine($"Index: Found {roverGroups.Count()} rovers with {newPoints.Count} total points");

            // Update trail and position for each rover
            foreach (var roverGroup in roverGroups)
            {
                var roverId = roverGroup.Key.RoverId;
                var roverName = roverGroup.Key.RoverName;
                var roverPoints = roverGroup.OrderBy(p => p.Sequence).ToList();
                
                if (roverPoints.Count == 0) continue;

                var prevCount = _pointCountPerRover.GetValueOrDefault(roverId, 0);

                if (_map != null)
                {
                    if (prevCount + roverPoints.Count >= 2)
                    {
                        if (prevCount < 2)
                        {
                            // Create full trail
                            var allThisRoverPoints = allPoints.Where(p => p.RoverId == roverId).OrderBy(p => p.Sequence).ToList();
                            var allCoords = allThisRoverPoints.Select(p => p.Geometry.Coordinate).ToArray();
                            var trail = new LineString(allCoords);
                            await _map.UpdateRoverTrailAsync(roverId, roverName, trail);
                        }
                        else
                        {
                            // Append new coordinates
                            var newCoords = roverPoints.Select(p => p.Geometry.Coordinate).ToArray();
                            await _map.AppendRoverTrailCoordsAsync(roverId, roverName, newCoords);
                        }
                    }
                    // Else skip trail if < 2 points total

                    var latest = roverPoints.Last();
                    await _map.UpdateRoverPositionAsync(
                        roverId,
                        roverName,
                        latest.Geometry,
                        latest.WindSpeedMps,
                        latest.WindDirectionDeg
                    );
                }
                
                // Update last sequence and point count for this rover
                _lastSequencePerRover[roverId] = roverPoints.Max(p => p.Sequence);
                _pointCountPerRover[roverId] = prevCount + roverPoints.Count;
                
                var action = prevCount == 0 ? "Initialized" : "Updated";
                Console.WriteLine($"Index: {action} rover {roverName} with {roverPoints.Count} points, last seq: {_lastSequencePerRover[roverId]}");
            }

            Console.WriteLine($"Index: Getting combined coverage polygon for {newPoints.Count} points...");
            var coverage = await generator.GetUnifiedPolygonAsync();
            Console.WriteLine($"Index: Coverage geometry null? {coverage?.Polygon == null}");
            if (coverage?.Polygon != null && _map != null)
            {
                Console.WriteLine($"Index: Calling UpdateCoverageAsync with geometry type {coverage.Polygon.GeometryType}");
                await _map.UpdateCoverageAsync(coverage.Polygon);
                Console.WriteLine("Index: UpdateCoverageAsync completed");
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            Console.WriteLine($"LoadDataAsync error: {ex}");
            await InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        _disposed = true;
        _timer?.Dispose();
    }
}