@* The functionallity in this file is:
   - Main page for rover tracking with DI-based data access
   - Use ScentMap component with C#-driven updates via Timer
   - Load initial data once, then poll for incremental updates
   - Direct access to IRoverDataReader and ScentPolygonService
*@

@page "/"
@using NetTopologySuite.Geometries
@inject IRoverDataReader Reader
@inject ScentPolygonService ScentService
@inject IJSRuntime JS
@implements IDisposable

<link href="css/fullscreen-map.css" rel="stylesheet" />

<!-- Overlay UI -->
<div class="overlay-top-left">
    <h3>FrontendLeaflet Rover Tracker</h3>
    <ForestCoveragePie />
</div>

@if (!string.IsNullOrEmpty(_error))
{
    <div class="overlay-error">Error: @_error</div>
}

<!-- ScentMap component -->
<ScentMap @ref="_map" />

@code {
    private ScentMap? _map;
    private Timer? _timer;
    private string? _error;
    private int _lastSequence = -1;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Load initial data
            await LoadInitialDataAsync();
            
            // Start timer for incremental updates (8 seconds)
            _timer = new Timer(async _ => await LoadIncrementalDataAsync(), null, 8000, 8000);
        }
        catch (Exception ex)
        {
            _error = $"Initialization failed: {ex.Message}";
            Console.WriteLine($"Error in OnInitializedAsync: {ex}");
        }
    }

    private async Task LoadInitialDataAsync()
    {
        try
        {
            // Get all measurements and create trail
            var measurements = await Reader.GetAllMeasurementsAsync();
            
            if (measurements.Any())
            {
                // Create LineString from all measurements
                var coordinates = measurements
                    .OrderBy(m => m.Sequence)
                    .Select(m => m.Geometry.Coordinate)
                    .ToArray();
                
                var lineString = new LineString(coordinates);
                
                // Update trail on map
                if (_map != null)
                {
                    await _map.UpdateTrailAsync(lineString);
                }
                
                // Update last sequence
                _lastSequence = measurements.Max(m => m.Sequence);
                
                Console.WriteLine($"Initial trail loaded: {coordinates.Length} points");
            }

            // Get unified scent polygon
            var unified = ScentService.GetUnifiedScentPolygonCached();
            if (unified != null && _map != null)
            {
                await _map.UpdateCoverageAsync(unified.Polygon);
                Console.WriteLine($"Coverage loaded: {unified.PolygonCount} polygons, {unified.TotalAreaM2:F0} mÂ²");
            }

            // Get latest position
            var latest = await Reader.GetLatestMeasurementAsync();
            if (latest != null && _map != null)
            {
                await _map.UpdatePositionAsync(latest.Geometry, latest.WindSpeedMps, latest.WindDirectionDeg);
                Console.WriteLine($"Position loaded: seq {latest.Sequence}");
            }
        }
        catch (Exception ex)
        {
            _error = $"Failed to load initial data: {ex.Message}";
            Console.WriteLine($"Error in LoadInitialDataAsync: {ex}");
        }
    }

    private async Task LoadIncrementalDataAsync()
    {
        try
        {
            // Check if there's new data
            RoverMeasurement? latest = await Reader.GetLatestMeasurementAsync();
            
            if (latest == null || latest.Sequence <= _lastSequence)
            {
                // No new data, but still update coverage and position
                await UpdateCoverageAndPositionAsync();
                return;
            }

            // Get new measurements since last sequence
            var newMeasurements = await Reader.GetNewMeasurementsAsync(_lastSequence);
            
            if (newMeasurements.Any() && _map != null)
            {
                // Append new coordinates to trail
                var newCoords = newMeasurements
                    .OrderBy(m => m.Sequence)
                    .Select(m => m.Geometry.Coordinate)
                    .ToArray();
                
                await _map.AppendTrailCoordsAsync(newCoords);
                
                // Update last sequence
                _lastSequence = newMeasurements.Max(m => m.Sequence);
                
                Console.WriteLine($"Appended {newCoords.Length} new points to trail (total seq: {_lastSequence})");
            }

            // Always update coverage and position
            await UpdateCoverageAndPositionAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in LoadIncrementalDataAsync: {ex.Message}");
        }
    }

    private async Task UpdateCoverageAndPositionAsync()
    {
        if (_map == null) return;

        try
        {
            // Update unified coverage
            var unified = ScentService.GetUnifiedScentPolygonCached();
            if (unified != null)
            {
                await _map.UpdateCoverageAsync(unified.Polygon);
            }

            // Update latest position
            var latest = await Reader.GetLatestMeasurementAsync();
            if (latest != null)
            {
                await _map.UpdatePositionAsync(latest.Geometry, latest.WindSpeedMps, latest.WindDirectionDeg);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating coverage/position: {ex.Message}");
        }
    }

    public void Dispose()
    {
        _timer?.Dispose();
    }
}
