@using NetTopologySuite.Geometries
@inject IJSRuntime JS
@implements IAsyncDisposable

<div id="@Id" style="position: fixed; inset: 0; width: 100vw; height: 100vh; z-index: 1; background: #dcdcdc;">
    @if (!_initialized)
    {
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #666; font-size: 1.5rem;">
            Initializing map...
        </div>
    }
</div>

@code {
    [Parameter]
    public string Id { get; set; } = "map";
    
    private bool _initialized = false;

    private IJSObjectReference? _module;
    private LineString? _trail;
    private Polygon? _coverage;
    private Point? _latestPosition;
    private float _windSpeed;
    private short _windDirection;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                Console.WriteLine($"ScentMap: OnAfterRenderAsync called for map '{Id}'");
                Console.WriteLine($"ScentMap: Importing module for map '{Id}'...");
                _module = await JS.InvokeAsync<IJSObjectReference>("import", "./js/scent-map.js");
                Console.WriteLine($"ScentMap: Module imported, calling initMap('{Id}')...");
                await _module.InvokeVoidAsync("initMap", Id);
                Console.WriteLine($"ScentMap: initMap('{Id}') complete");
                _initialized = true;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ScentMap: Error initializing map: {ex.Message}");
                Console.WriteLine($"ScentMap: Stack trace: {ex.StackTrace}");
            }
        }
    }

    public async Task UpdateTrailAsync(LineString trail)
    {
        if (_module == null || trail == null) return;
        
        _trail = trail;
        var floatArray = trail.Coordinates.ToFloatArray();
        await _module.InvokeVoidAsync("updateTrail", Id, floatArray);
    }

    public async Task UpdateCoverageAsync(Polygon coverage)
    {
        if (_module == null || coverage == null) return;
        
        _coverage = coverage;
        var floatArray = coverage.ExteriorRing.Coordinates.ToFloatArray();
        await _module.InvokeVoidAsync("updateCoverage", Id, floatArray);
    }

    public async Task UpdatePositionAsync(Point position, float windSpeed, short windDirection)
    {
        if (_module == null || position == null) return;
        
        _latestPosition = position;
        _windSpeed = windSpeed;
        _windDirection = windDirection;
        
        await _module.InvokeVoidAsync("updatePosition", Id, position.X, position.Y, windSpeed, windDirection);
    }

    public async Task AppendTrailCoordsAsync(Coordinate[] newCoords)
    {
        if (_module == null || newCoords == null || newCoords.Length == 0) return;
        
        var floatArray = newCoords.ToFloatArray();
        await _module.InvokeVoidAsync("appendTrail", Id, floatArray);
    }

    public async ValueTask DisposeAsync()
    {
        if (_module != null)
        {
            try
            {
                await _module.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}
